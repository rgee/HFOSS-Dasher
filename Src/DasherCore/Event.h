#ifndef __event_h__
#define __event_h__

// Classes representing different event types.

#include <string>
#include "DasherTypes.h"


namespace Dasher {
  class CEvent;
  class CParameterNotificationEvent;
  class CEditEvent;
  class CEditContextEvent;
  class CStartEvent;
  class CStopEvent;
  class CControlEvent;
  class CLockEvent;
  class CGameTargetChangedEvent;
  class CGameNodeDrawEvent;
  class CMessageEvent;
  class CCommandEvent;
  class CDasherView;
  class CDasherNode;
  class CNoGameNodeEvent;
}

/*
 * The enumeration of event types. Whenever you add a new event type,
 * you must add its enum representation here. You must also make sure
 * to change the constant in EventHandler that refers to the number of events
 * or you will likely get errors.
 */
enum {
  EV_PARAM_NOTIFY = 1, EV_EDIT, EV_EDIT_CONTEXT, EV_START, EV_STOP, EV_CONTROL, EV_LOCK, EV_GAME_TARGET_CHANGED, EV_MESSAGE, EV_COMMAND, EV_GAME_NODE_DRAWN,
  EV_NO_GAME_NODE
};

/// \ingroup Core
/// @{

/// \defgroup Events Events generated by Dasher modules.
/// @{
class Dasher::CEvent {
public:
  int m_iEventType;
};

/**
 * An event that represents when the game target node cannot be found
 * among the current last-typed node's children. Since the set of child
 * nodes is a set consisting of all possible characters in the current
 * alphabet, the only way for it not to exist at all is if it was not
 * drawn yet.
 */
class Dasher::CNoGameNodeEvent : public Dasher::CEvent {
public:
  CNoGameNodeEvent(std::pair<CDasherNode*, CDasherNode*> pNodes)
    : m_pNodes(pNodes) {
      m_iEventType = EV_NO_GAME_NODE;
  };
  
  /**
   * The pair of nodes that represent the closest drawn nodes to the top
   * and bottom of where the target node /should/ be.
   * 
   * If the left of this pair is null, the target node is at the top-most
   * node in the current subtree of the model (in Dasher space).
   * 
   * Conversely, if the right of this pair is null, the target node exists
   * at the bottom of the current subtree of the model.
   */
  std::pair<CDasherNode*, CDasherNode*> m_pNodes;
};

/**
 * An event that notifies listeners that a node previously flagged for
 * game mode has been drawn.
 */
class Dasher::CGameNodeDrawEvent : public Dasher::CEvent {
public:
  CGameNodeDrawEvent(CDasherNode* pNode, CDasherView* pView, screenint iX, screenint iY)
    : m_pNode(pNode),
      m_pView(pView),
      m_iX(iX),
      m_iY(iY) {
      m_iEventType = EV_GAME_NODE_DRAWN;
  };
  
  /**
   * The node itself.
   */
  CDasherNode* m_pNode;

  /**
   * the coordinates at which m_pNode was drawn.
   */
  screenint m_iX, m_iY;

  /**
   * View object for manipulating the screen.
   */
  CDasherView* m_pView;
};

class Dasher::CGameTargetChangedEvent : public Dasher::CEvent {
public:
  CGameTargetChangedEvent(std::string strTargetText)
    : m_strTargetText(strTargetText) {
      m_iEventType = EV_GAME_TARGET_CHANGED;
  };
  
  std::string m_strTargetText;
};

class Dasher::CParameterNotificationEvent:public Dasher::CEvent {
public:
  CParameterNotificationEvent(int iParameter) {
    m_iEventType = EV_PARAM_NOTIFY;
    m_iParameter = iParameter;
  };

  int m_iParameter;
};

class Dasher::CEditEvent:public Dasher::CEvent {
public:
  CEditEvent(int iEditType, const std::string & sText, int iOffset) {
    m_iEventType = EV_EDIT;
    m_iEditType = iEditType;
    m_sText = sText;
    m_iOffset = iOffset;
  };

  int m_iEditType;
  std::string m_sText;
  int m_iOffset;
};

class Dasher::CEditContextEvent:public Dasher::CEvent {
public:
  CEditContextEvent(int iOffset, int iLength) {
    m_iEventType = EV_EDIT_CONTEXT;
    m_iOffset = iOffset;
    m_iLength = iLength;
  };

  int m_iOffset;
  int m_iLength;
};

class Dasher::CStartEvent:public Dasher::CEvent {
public:
  CStartEvent() {
    m_iEventType = EV_START;
  };
};

class Dasher::CStopEvent:public Dasher::CEvent {
public:
  CStopEvent() {
    m_iEventType = EV_STOP;
  };
};

class Dasher::CControlEvent:public Dasher::CEvent {
public:
  CControlEvent(int iID) {
    m_iEventType = EV_CONTROL;
    m_iID = iID;
  };
  
  int m_iID;
};

class Dasher::CLockEvent : public Dasher::CEvent {
public:
  CLockEvent(const std::string &strMessage, bool bLock, int iPercent) {
    m_iEventType = EV_LOCK;
    m_strMessage = strMessage;
    m_bLock = bLock;
    m_iPercent = iPercent;
  };
  
  std::string m_strMessage;
  bool m_bLock;
  int m_iPercent;
};

class Dasher::CMessageEvent : public Dasher::CEvent {
public:
  CMessageEvent(const std::string &strMessage, int iID, int iType) {
    m_iEventType = EV_MESSAGE;
    m_strMessage = strMessage;
    m_iID = iID;
    m_iType = iType;
  };
  
  std::string m_strMessage;
  int m_iID;
  int m_iType;
};

class Dasher::CCommandEvent : public Dasher::CEvent {
public:
  CCommandEvent(const std::string &strCommand) {
    m_iEventType = EV_COMMAND;
    m_strCommand = strCommand;
  };
  
  std::string m_strCommand;
};
/// @}
/// @}

#endif
